<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  
  <!-- SEO Î∞è ÌéòÏù¥ÏßÄ Ï†ïÎ≥¥ -->
  <title>2026 Ïó∞ÌïòÏû• | 2026 New Year Celebration</title>
  <meta name="description" content="2026ÎÖÑ ÏÉàÌï¥ Î≥µ ÎßéÏù¥ Î∞õÏúºÏÑ∏Ïöî! ÎßåÎì†Ïù¥: work.kyung@gmail.com">
  <meta name="keywords" content="2026, Ïó∞ÌïòÏû•, ÎßåÌôîÍ≤Ω, ÏÉàÌï¥Ïù∏ÏÇ¨, Î≥ëÏò§ÎÖÑ, ÎîîÏßÄÌÑ∏ÏïÑÌä∏, Kaleidoscope, New Year Card, 2026ÎÖÑ Ïù∏ÏÇ¨Îßê">
  <meta name="author" content="work.kyung@gmail.com">
  
  <!-- Ïò§ÌîàÍ∑∏ÎûòÌîÑ (Ïπ¥Ïπ¥Ïò§ÌÜ°, ÌéòÏù¥Ïä§Î∂Å Îì± Í≥µÏú† ÎØ∏Î¶¨Î≥¥Í∏∞) -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="2026 Ïó∞ÌïòÏû• | 2026 New Year Celebration">
  <meta property="og:description" content="2026ÎÖÑ ÏÉàÌï¥ Î≥µ ÎßéÏù¥ Î∞õÏúºÏÑ∏Ïöî!">
  <meta id="og-image" property="og:image" content="og-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta id="og-url" property="og:url" content="">
  <meta property="og:site_name" content="2026 ÎßåÌôîÍ≤Ω Ïó∞ÌïòÏû•">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="2026 Ïó∞ÌïòÏû• | 2026 New Year Celebration">
  <meta name="twitter:description" content="2026ÎÖÑ ÏÉàÌï¥ Î≥µ ÎßéÏù¥ Î∞õÏúºÏÑ∏Ïöî!">
  <meta id="twitter-image" name="twitter:image" content="og-image.png">

  <!-- Î©îÌÉÄ ÌÉúÍ∑∏ ÎèôÏ†Å Î≥¥Ï†ï Ïä§ÌÅ¨Î¶ΩÌä∏: ÏÉÅÎåÄ Í≤ΩÎ°úÎ•º Ï†àÎåÄ Í≤ΩÎ°úÎ°ú Î≥ÄÌôò -->
  <script>
    (function() {
      const currentUrl = window.location.href.split('?')[0].split('#')[0];
      const origin = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '');
      const imageUrl = origin + '/og-image.png';
      
      document.getElementById('og-url').setAttribute('content', currentUrl);
      document.getElementById('og-image').setAttribute('content', imageUrl);
      document.getElementById('twitter-image').setAttribute('content', imageUrl);
    })();
  </script>

  <!-- ÌååÎπÑÏΩò: Îßê Ïù¥Î™®ÏßÄ(üêé) -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üêé</text></svg>">

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Unbounded:wght@200;400;900&family=Outfit:wght@200;600;900&family=Noto+Sans+KR:wght@300;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root {
      --color-cream: #FEF7E5;
      --color-red: #F15A2B;
      --color-blue: #8CBEE3;
      --color-dark-blue: #212C3A;
      --color-orange: #FBB03B;
    }
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: var(--color-dark-blue);
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      font-family: 'Outfit', sans-serif;
      color: var(--color-dark-blue);
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    .permission-overlay {
      background: var(--color-cream);
      z-index: 100;
    }
    .font-unbounded { font-family: 'Unbounded', sans-serif; }
    
    .btn-minimal {
      border: 1px solid var(--color-red);
      background: var(--color-red);
      color: #fff;
      transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
    }
    .btn-minimal:hover {
      background: var(--color-red);
      color: #fff;
      filter: brightness(1.1);
      transform: scale(1.02) translateY(0px);
    }
    
    @keyframes bounce-floor {
      0%, 100% { 
        transform: translateY(0px) scaleY(1); 
        animation-timing-function: cubic-bezier(0, 0, 0.2, 1); 
      }
      50% { 
        transform: translateY(-8px) scaleY(1.02); 
        animation-timing-function: cubic-bezier(0.8, 0, 1, 1); 
      }
    }
    .animate-bounce-floor {
      animation: bounce-floor 1.15s infinite; 
    }

    .drop-shadow-strong {
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5));
    }
    
    .text-2026-custom {
      font-weight: 200;
      letter-spacing: -0.02em;
    }

    .text-nyc-custom {
      font-weight: 900;
      letter-spacing: -0.01em;
      line-height: 1;
    }

    .emoji-icon-static {
      filter: grayscale(1) brightness(10);
      opacity: 0.9;
    }

    .share-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(255,255,255,0.15);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      z-index: 1000;
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.2);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef, useCallback, useImperativeHandle, forwardRef } from 'https://esm.sh/react@19.0.0';
    import { createRoot } from 'https://esm.sh/react-dom@19.0.0/client';

    const THEME_PALETTE = ["#F15A2B", "#8CBEE3", "#212C3A", "#FBB03B", "#FFFFFF", "#FEF7E5"];
    const GEMS_CONTENT = ["üêé", "Á¶è", "2026", "‚ú®", "üå∏", "üèÆ", "üßß", "üéä", "üå∫", "üêé", "üßß", "üí´"];

    const KaleidoscopeCanvas = forwardRef(({ settings, videoStream }, ref) => {
      const canvasRef = useRef(null);
      const videoRef = useRef(null);
      const beadsRef = useRef([]);
      const offscreenRef = useRef(null);
      const rafRef = useRef(null);

      const createBead = useCallback((customProps = {}) => {
        const colorIndex = Math.floor(Math.random() * THEME_PALETTE.length);
        const color = THEME_PALETTE[colorIndex];
        
        const isDark = color === "#212C3A";
        const randomSize = isDark ? (Math.random() * 4 + 4) : (Math.random() * 20 + 12);
        const contentIndex = Math.floor(Math.random() * GEMS_CONTENT.length);
        
        return {
          x: 0, y: 0,
          vx: (Math.random() - 0.5) * 0.4,
          vy: (Math.random() - 0.5) * 0.4,
          size: randomSize, 
          color: color,
          rot: Math.random() * Math.PI * 2,
          vRot: (Math.random() - 0.5) * 0.1, 
          content: GEMS_CONTENT[contentIndex],
          type: contentIndex < 3 ? 'text' : 'shape',
          createdAt: performance.now(),
          alpha: 1,
          ...customProps
        };
      }, []);

      useImperativeHandle(ref, () => ({
        handleAction: (e) => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const rect = canvas.getBoundingClientRect();
          const w = rect.width, h = rect.height;
          const radius = Math.hypot(w, h) * 0.5;
          const sliceAngle = (Math.PI * 2) / settings.segments;

          let spawnX, spawnY;
          if (e && e.clientX !== undefined) {
            const rawX = e.clientX - rect.left - w/2;
            const rawY = e.clientY - rect.top - h/2;
            const dist = Math.hypot(rawX, rawY);
            if (dist > radius) return;
            let angle = Math.atan2(rawY, rawX);
            if (angle < 0) angle += Math.PI * 2;
            let localAngle = angle % sliceAngle;
            if (Math.floor(angle / sliceAngle) % 2 === 1) localAngle = sliceAngle - localAngle;
            spawnX = Math.cos(localAngle) * dist;
            spawnY = Math.sin(localAngle) * dist;
          } else {
            spawnX = (Math.random() - 0.5) * radius * 0.6;
            spawnY = (Math.random() - 0.5) * radius * 0.6;
          }

          const count = Math.floor(Math.random() * 8) + 8;
          for (let i = 0; i < count; i++) {
            beadsRef.current.push(createBead({
              x: spawnX, y: spawnY,
              vx: (Math.random() - 0.5) * 30, vy: (Math.random() - 0.5) * 30,
              vRot: (Math.random() - 0.5) * 1.2
            }));
          }
          if (beadsRef.current.length > 250) beadsRef.current = beadsRef.current.slice(-250);
        }
      }));

      useEffect(() => {
        if (videoStream) {
          if (!videoRef.current) {
            const video = document.createElement('video');
            video.srcObject = videoStream;
            video.setAttribute('playsinline', '');
            video.play().catch(console.error);
            videoRef.current = video;
          } else {
            videoRef.current.srcObject = videoStream;
          }
        }
      }, [videoStream]);

      const animate = useCallback((time) => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        const w = window.innerWidth, h = window.innerHeight;
        if (canvas.width !== w || canvas.height !== h) { 
          canvas.width = w; canvas.height = h; 
        }

        const radius = Math.hypot(w, h) * 0.52;
        const slice = (Math.PI * 2) / settings.segments;

        if (!offscreenRef.current) offscreenRef.current = document.createElement('canvas');
        const offSize = Math.ceil(radius);
        if (offscreenRef.current.width !== offSize) { 
          offscreenRef.current.width = offscreenRef.current.height = offSize; 
        }
        const octx = offscreenRef.current.getContext('2d');
        if (!octx) return;

        beadsRef.current = beadsRef.current.filter(b => {
          const age = (time - b.createdAt) / 1000;
          if (age >= 4.0) return false;
          b.alpha = age > 3.0 ? 1 - (age - 3.0) / 1.0 : 1;
          b.vx *= 0.98; b.vy *= 0.98;
          b.vy += 0.05;
          b.x += b.vx; b.y += b.vy;
          b.rot += b.vRot;
          const d = Math.hypot(b.x, b.y);
          if (d > radius) {
            const angle = Math.atan2(b.y, b.x);
            b.x = Math.cos(angle) * radius; b.y = Math.sin(angle) * radius;
            b.vx *= -0.7; b.vy *= -0.7;
          }
          return true;
        });

        octx.clearRect(0, 0, offSize, offSize);
        
        if (videoRef.current && videoRef.current.readyState >= 2) {
          const vw = videoRef.current.videoWidth, vh = videoRef.current.videoHeight;
          const vScale = Math.max(radius * 2 / vw, radius * 2 / vh); 
          octx.save();
          octx.scale(-1, 1);
          octx.globalAlpha = 0.7;
          octx.drawImage(
            videoRef.current, 
            -vw * vScale * 0.5, 
            -vh * vScale * 0.5, 
            vw * vScale, 
            vh * vScale
          );
          octx.restore();
        }

        octx.save();
        octx.globalCompositeOperation = 'overlay'; 
        octx.fillStyle = '#F15A2B11'; 
        octx.fillRect(0, 0, offSize, offSize);
        octx.restore();

        octx.save();
        octx.globalCompositeOperation = 'lighter'; 
        beadsRef.current.forEach(b => {
          octx.save();
          octx.translate(b.x, b.y); 
          octx.rotate(b.rot); 
          octx.globalAlpha = b.alpha;
          octx.fillStyle = b.color;
          
          if (b.type === 'text') {
            octx.font = `bold ${b.size}px "Noto Sans KR"`;
            octx.textAlign = 'center'; octx.textBaseline = 'middle';
            octx.fillText(b.content, 0, 0);
          } else {
            octx.beginPath();
            octx.arc(0, 0, b.size/2, 0, Math.PI * 2);
            octx.fill();
          }
          octx.restore();
        });
        octx.restore();

        ctx.fillStyle = '#111'; ctx.fillRect(0,0,w,h);
        ctx.save();
        ctx.translate(w/2, h/2);
        for(let i=0; i<settings.segments; i++) {
          ctx.save();
          ctx.rotate(i * slice);
          ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,radius,0,slice + 0.005); ctx.clip();
          if(i%2===1) { ctx.scale(1,-1); ctx.rotate(-slice); }
          ctx.drawImage(offscreenRef.current, 0, 0);
          ctx.restore();
        }
        ctx.restore();

        rafRef.current = requestAnimationFrame(animate);
      }, [settings]);

      useEffect(() => {
        rafRef.current = requestAnimationFrame(animate);
        return () => { if (rafRef.current) cancelAnimationFrame(rafRef.current); };
      }, [animate]);

      return <canvas ref={canvasRef} />;
    });

    const App = () => {
      const [permissionGranted, setPermissionGranted] = useState(false);
      const [videoStream, setVideoStream] = useState(null);
      const kaleidoscopeRef = useRef(null);
      const settings = { segments: 12 };

      const handleShare = async (e) => {
        e.stopPropagation();
        if (navigator.share) {
          try {
            await navigator.share({
              title: '2026 Ïó∞ÌïòÏû• | 2026 New Year Celebration',
              text: '2026ÎÖÑ ÏÉàÌï¥ Î≥µ ÎßéÏù¥ Î∞õÏúºÏÑ∏Ïöî!',
              url: window.location.href,
            });
          } catch (err) {
            console.log('Í≥µÏú† Ïã§Ìå® ÎòêÎäî Ï∑®ÏÜå:', err);
          }
        } else {
          alert('Í≥µÏú†ÌïòÍ∏∞ Í∏∞Îä•Ïù¥ ÏßÄÏõêÎêòÏßÄ ÏïäÎäî Î∏åÎùºÏö∞Ï†ÄÏûÖÎãàÎã§. ÎßÅÌÅ¨Î•º Î≥µÏÇ¨Ìï¥Ï£ºÏÑ∏Ïöî!');
        }
      };

      const requestPermissions = async () => {
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
          try { await DeviceMotionEvent.requestPermission(); } catch (e) { console.error(e); }
        }
        
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
              facingMode: 'environment',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            } 
          });
          setVideoStream(stream);
        } catch (e) {
          console.warn("Camera access denied", e);
        }

        const handleMotion = (e) => {
          const acc = e.accelerationIncludingGravity;
          if (acc && (Math.abs(acc.x || 0) > 10 || Math.abs(acc.y || 0) > 10 || Math.abs(acc.z || 0) > 10)) {
            kaleidoscopeRef.current?.handleAction();
          }
        };

        window.addEventListener('devicemotion', handleMotion);
        setPermissionGranted(true);
      };

      return (
        <div className="relative w-full h-screen overflow-hidden bg-black" onPointerDown={(e) => kaleidoscopeRef.current?.handleAction(e)}>
          <KaleidoscopeCanvas ref={kaleidoscopeRef} settings={settings} videoStream={videoStream} />
          
          {permissionGranted && (
            <div className="share-btn" onClick={handleShare}>
              <i className="fa-solid fa-share-nodes"></i>
            </div>
          )}

          {!permissionGranted && (
            <div className="fixed inset-0 flex flex-col items-center permission-overlay z-[100]">
              {/* HEADER */}
              <div className="w-full flex flex-col items-center pt-[15vh] px-8 text-center">
                <h1 className="font-unbounded text-8xl md:text-9xl text-2026-custom text-[#212C3A] mb-4">2026</h1>
                <p className="text-[18px] md:text-2xl text-nyc-custom text-[#F15A2B] uppercase">New Year Celebration</p>
              </div>
              
              {/* CENTERED BUTTON */}
              <div className="flex-grow flex items-center justify-center w-full px-8">
                <button 
                  onClick={(e) => { e.stopPropagation(); requestPermissions(); }} 
                  className="btn-minimal px-20 py-4 rounded-full text-sm tracking-[0.4em] uppercase font-bold shadow-sm animate-bounce-floor"
                >
                  Start
                </button>
              </div>
              
              {/* BOTTOM FOOTER */}
              <div className="w-full text-center text-[#8CBEE3] font-bold px-4 flex flex-col gap-1.5 items-center pb-12">
                 <span className="font-['Noto_Sans_KR'] text-[11px] tracking-widest text-[#212C3A] opacity-90">Ïπ¥Î©îÎùº Î∞è ÎèôÏûë ÏÑºÏÑú Ï†ëÍ∑ºÏùÑ ÌóàÏö©Ìï¥ Ï£ºÏÑ∏Ïöî</span>
                 <span className="text-[13px] text-[#8CBEE3] tracking-[0.1em] font-light mt-2">work.kyung@gmail.com</span>
              </div>
            </div>
          )}

          {permissionGranted && (
            <div className="absolute inset-x-0 top-[100px] text-center pointer-events-none z-50 flex flex-col items-center px-4">
               <div className="flex items-center justify-center gap-4 mb-4">
                 <span className="text-xl md:text-2xl emoji-icon-static">üêé</span>
                 <h2 className="text-3xl md:text-5xl font-black text-white tracking-[0.2em] leading-tight drop-shadow-2xl">
                   <span className="block md:inline">HAPPY</span>
                   <span className="block md:inline md:ml-4">NEW YEAR</span>
                 </h2>
                 <span className="text-xl md:text-2xl emoji-icon-static">‚ú®</span>
               </div>
               <p className="text-[11px] tracking-[0.2em] text-white/90 font-bold drop-shadow-lg bg-black/20 px-6 py-1.5 rounded-full backdrop-blur-sm font-['Noto_Sans_KR']">
                 Ìï∏ÎìúÌè∞ÏùÑ ÌùîÎì§Í±∞ÎÇò ÌôîÎ©¥ÏùÑ ÌÑ∞ÏπòÌïòÏÑ∏Ïöî
               </p>
            </div>
          )}
        </div>
      );
    };

    const container = document.getElementById('root');
    if (container) {
      const root = createRoot(container);
      root.render(<App />);
    }
  </script>
</body>
</html>