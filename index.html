<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>2026 ÎßåÌôîÍ≤Ω Ïó∞ÌïòÏû•</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Unbounded:wght@400;900&family=Outfit:wght@200;600&family=Noto+Sans+KR:wght@300;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root {
      --color-cream: #FEF7E5;
      --color-red: #F15A2B;
      --color-blue: #8CBEE3;
      --color-dark-blue: #212C3A;
      --color-orange: #FBB03B;
    }
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: var(--color-cream);
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      font-family: 'Outfit', sans-serif;
      color: var(--color-dark-blue);
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    .permission-overlay {
      background: var(--color-cream);
      z-index: 100;
    }
    .font-unbounded { font-family: 'Unbounded', sans-serif; }
    
    .btn-minimal {
      border: 1px solid var(--color-red);
      background: transparent;
      color: var(--color-red);
      transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
    }
    .btn-minimal:hover {
      background: var(--color-red);
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef, useCallback, useImperativeHandle, forwardRef } from 'https://esm.sh/react@19.0.0';
    import { createRoot } from 'https://esm.sh/react-dom@19.0.0/client';

    const THEME_PALETTE = ["#F15A2B", "#8CBEE3", "#212C3A", "#FBB03B", "#FFFFFF", "#FEF7E5"];
    const GEMS_CONTENT = ["üêé", "Á¶è", "2026", "‚ú®", "üå∏", "üèÆ", "üßß", "üéä", "üå∫", "üêé"];

    const KaleidoscopeCanvas = forwardRef(({ settings, videoStream }, ref) => {
      const canvasRef = useRef(null);
      const videoRef = useRef(null);
      const beadsRef = useRef([]);
      const offscreenRef = useRef(null);
      const rafRef = useRef(null);

      const createBead = useCallback((customProps = {}) => {
        const colorIndex = Math.floor(Math.random() * THEME_PALETTE.length);
        const color = THEME_PALETTE[colorIndex];
        
        const isDark = color === "#212C3A";
        const randomSize = isDark ? (Math.random() * 4 + 4) : (Math.random() * 18 + 10);
        const contentIndex = Math.floor(Math.random() * GEMS_CONTENT.length);
        
        return {
          x: 0, y: 0,
          vx: (Math.random() - 0.5) * 0.4,
          vy: (Math.random() - 0.5) * 0.4,
          size: randomSize, 
          color: color,
          rot: Math.random() * Math.PI * 2,
          vRot: (Math.random() - 0.5) * 0.1, 
          content: GEMS_CONTENT[contentIndex],
          type: contentIndex < 3 ? 'text' : 'shape',
          createdAt: performance.now(),
          alpha: 1,
          ...customProps
        };
      }, []);

      useImperativeHandle(ref, () => ({
        handleAction: (e) => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const rect = canvas.getBoundingClientRect();
          const w = rect.width, h = rect.height;
          const radius = Math.hypot(w, h) * 0.5 * settings.zoom;
          const sliceAngle = (Math.PI * 2) / settings.segments;

          let spawnX, spawnY;
          if (e && e.clientX !== undefined) {
            const rawX = e.clientX - rect.left - w/2;
            const rawY = e.clientY - rect.top - h/2;
            const dist = Math.hypot(rawX, rawY);
            if (dist > radius) return;
            let angle = Math.atan2(rawY, rawX);
            if (angle < 0) angle += Math.PI * 2;
            let localAngle = angle % sliceAngle;
            if (Math.floor(angle / sliceAngle) % 2 === 1) localAngle = sliceAngle - localAngle;
            spawnX = Math.cos(localAngle) * dist;
            spawnY = Math.sin(localAngle) * dist;
          } else {
            spawnX = (Math.random() - 0.5) * radius * 0.4;
            spawnY = (Math.random() - 0.5) * radius * 0.4;
          }

          const count = Math.floor(Math.random() * 4) + 4;
          for (let i = 0; i < count; i++) {
            beadsRef.current.push(createBead({
              x: spawnX, y: spawnY,
              vx: (Math.random() - 0.5) * 18, vy: (Math.random() - 0.5) * 18,
              vRot: (Math.random() - 0.5) * 0.8
            }));
          }
          if (beadsRef.current.length > 120) beadsRef.current = beadsRef.current.slice(-120);
        }
      }));

      useEffect(() => {
        if (videoStream) {
          if (!videoRef.current) {
            const video = document.createElement('video');
            video.srcObject = videoStream;
            video.setAttribute('playsinline', '');
            video.play().catch(console.error);
            videoRef.current = video;
          } else {
            videoRef.current.srcObject = videoStream;
          }
        }
      }, [videoStream]);

      const animate = useCallback((time) => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        const w = window.innerWidth, h = window.innerHeight;
        if (canvas.width !== w || canvas.height !== h) { 
          canvas.width = w; canvas.height = h; 
        }

        const radius = Math.hypot(w, h) * 0.6 * settings.zoom;
        const slice = (Math.PI * 2) / settings.segments;

        if (!offscreenRef.current) offscreenRef.current = document.createElement('canvas');
        const offSize = Math.ceil(radius);
        if (offscreenRef.current.width !== offSize) { 
          offscreenRef.current.width = offscreenRef.current.height = offSize; 
        }
        const octx = offscreenRef.current.getContext('2d');
        if (!octx) return;

        beadsRef.current = beadsRef.current.filter(b => {
          const age = (time - b.createdAt) / 1000;
          if (age >= 3.5) return false;
          b.alpha = age > 2.5 ? 1 - (age - 2.5) / 1.0 : 1;
          b.vx *= 0.98; b.vy *= 0.98;
          b.vy += 0.05; 
          b.x += b.vx; b.y += b.vy;
          b.rot += b.vRot;
          const d = Math.hypot(b.x, b.y);
          if (d > radius) {
            const angle = Math.atan2(b.y, b.x);
            b.x = Math.cos(angle) * radius; b.y = Math.sin(angle) * radius;
            b.vx *= -0.7; b.vy *= -0.7;
          }
          return true;
        });

        octx.clearRect(0, 0, offSize, offSize);
        
        // Î∞∞Í≤Ω ÎπÑÎîîÏò§ Î†àÏù¥Ïñ¥
        if (videoRef.current && videoRef.current.readyState >= 2) {
          const vw = videoRef.current.videoWidth, vh = videoRef.current.videoHeight;
          const vScale = Math.max(offSize/vw, offSize/vh);
          octx.save();
          octx.translate(offSize/2, offSize/2);
          octx.scale(-1, 1);
          octx.globalAlpha = 0.5;
          octx.drawImage(videoRef.current, -vw*vScale/2, -vh*vScale/2, vw*vScale, vh*vScale);
          octx.restore();
        }

        // Ïä§ÌÅ¨Î¶∞(Î∞ùÍ≤å ÌïòÍ∏∞) Î™®Îìú Ï†ÅÏö© - Î∞∞Í≤Ω Î≤†Ïù¥Ïä§
        octx.save();
        octx.globalCompositeOperation = 'screen'; 
        octx.fillStyle = '#F15A2B33'; 
        octx.fillRect(0, 0, offSize, offSize);
        octx.restore();

        // Í∑∏ÎûòÌîΩ ÏöîÏÜå(Íµ¨Ïä¨/Ï†¨) Í∑∏Î¶¨Í∏∞ - Í≤πÏπ†ÏàòÎ°ù Î∞ùÏïÑÏßÄÎèÑÎ°ù 'lighter' Ï†ÅÏö©
        octx.save();
        octx.globalCompositeOperation = 'lighter'; 
        beadsRef.current.forEach(b => {
          octx.save();
          octx.translate(b.x, b.y); 
          octx.rotate(b.rot); 
          octx.globalAlpha = b.alpha;
          octx.fillStyle = b.color;
          
          if (b.type === 'text') {
            octx.font = `bold ${b.size}px "Noto Sans KR"`;
            octx.textAlign = 'center'; octx.textBaseline = 'middle';
            octx.fillText(b.content, 0, 0);
          } else {
            octx.beginPath();
            octx.arc(0, 0, b.size/2, 0, Math.PI * 2);
            octx.fill();
          }
          octx.restore();
        });
        octx.restore();

        // Î©îÏù∏ Ï∫îÎ≤ÑÏä§Ïóê ÎßåÌôîÍ≤Ω Ìå®ÌÑ¥ÏúºÎ°ú Î≥µÏ†ú
        ctx.fillStyle = '#FEF7E5'; ctx.fillRect(0,0,w,h);
        ctx.save();
        ctx.translate(w/2, h/2);
        for(let i=0; i<settings.segments; i++) {
          ctx.save();
          ctx.rotate(i * slice);
          ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,radius,0,slice+0.01); ctx.clip();
          if(i%2===1) { ctx.scale(1,-1); ctx.rotate(-slice); }
          ctx.drawImage(offscreenRef.current, 0, 0);
          ctx.restore();
        }
        ctx.restore();

        rafRef.current = requestAnimationFrame(animate);
      }, [settings]);

      useEffect(() => {
        rafRef.current = requestAnimationFrame(animate);
        return () => { if (rafRef.current) cancelAnimationFrame(rafRef.current); };
      }, [animate]);

      return <canvas ref={canvasRef} />;
    });

    const App = () => {
      const [permissionGranted, setPermissionGranted] = useState(false);
      const settings = { segments: 12, zoom: 1.6 };
      const [videoStream, setVideoStream] = useState(null);
      const kaleidoscopeRef = useRef(null);

      const requestPermissions = async () => {
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
          try { await DeviceMotionEvent.requestPermission(); } catch (e) { console.error(e); }
        }
        
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
          setVideoStream(stream);
        } catch (e) {
          console.warn("Camera access denied", e);
        }

        const handleMotion = (e) => {
          const acc = e.accelerationIncludingGravity;
          if (acc && (Math.abs(acc.x || 0) > 11 || Math.abs(acc.y || 0) > 11)) {
            kaleidoscopeRef.current?.handleAction();
          }
        };

        window.addEventListener('devicemotion', handleMotion);
        setPermissionGranted(true);
      };

      return (
        <div className="relative w-full h-screen overflow-hidden" onPointerDown={(e) => kaleidoscopeRef.current?.handleAction(e)}>
          <KaleidoscopeCanvas ref={kaleidoscopeRef} settings={settings} videoStream={videoStream} />
          
          {!permissionGranted && (
            <div className="fixed inset-0 flex flex-col items-center justify-start pt-[15vh] p-8 text-center permission-overlay z-[100]">
              <div className="w-full flex flex-col items-center mb-[10vh]">
                <h1 className="font-unbounded text-8xl md:text-9xl font-black text-[#F15A2B] tracking-tighter mb-4">2026</h1>
                <p className="text-[11px] tracking-[1em] text-[#212C3A] uppercase font-bold">New Year Celebration</p>
              </div>
              
              <div className="flex flex-col items-center gap-1 mt-auto mb-[15vh]">
                <button 
                  onClick={(e) => { e.stopPropagation(); requestPermissions(); }} 
                  className="btn-minimal px-20 py-4 rounded-full text-sm tracking-[0.4em] uppercase font-bold mb-3 shadow-sm"
                >
                  Start
                </button>
                <p className="text-[12px] text-[#F15A2B] font-bold">Ìï∏ÎìúÌè∞ÏùÑ ÌùîÎì§Í±∞ÎÇò ÌôîÎ©¥ÏùÑ ÌÑ∞ÏπòÌïòÏÑ∏Ïöî</p>
              </div>
              
              <div className="absolute bottom-12 left-0 right-0 text-center text-[10px] tracking-[0.3em] text-[#8CBEE3] font-bold uppercase px-4">
                 Camera & Motion Sensor permissions required
              </div>
            </div>
          )}

          {permissionGranted && (
            <div className="absolute inset-x-0 top-[100px] text-center pointer-events-none z-50 flex flex-col items-center">
               <h2 className="font-unbounded text-2xl md:text-3xl font-black text-white tracking-[0.2em] mb-3">
                 HAPPY NEW YEAR
               </h2>
               <p className="text-[10px] tracking-[0.4em] text-white/60 font-bold uppercase">
                 Shake or Touch
               </p>
            </div>
          )}
        </div>
      );
    };

    const container = document.getElementById('root');
    if (container) {
      const root = createRoot(container);
      root.render(<App />);
    }
  </script>
</body>
</html>